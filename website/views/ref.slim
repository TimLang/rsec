/GENERATED BY rake gen:ref
h3
  | lazy
  span.constraints title='should include Rsec::Helper' helper
pre.desc
  | Lazy parser
i.example example:
pre.code
  code.prettyprint.lang-rb
    | parser = lazy{future}
      future = 'jim'.r
      assert_equal 'jim', parser.parse '12323'
h3
  | one_of
  span.params title='params'
    ' (str)
  span.constraints title='should include Rsec::Helper' helper
pre.desc
  | Parses one of chars in str
i.example example:
pre.code
  code.prettyprint.lang-rb
    | multiplicative = one_of '*/%'
      assert_equal '/', multiplicative.parse '/'
      assert_equal Rsec::INVALID, actualmultiplicative.parse '+'
h3
  | one_of_
  span.params title='params'
    ' (str)
  span.constraints title='should include Rsec::Helper' helper
pre.desc
  | See also #one_of#, with leading and trailing optional breakable spaces
i.example example:
pre.code
  code.prettyprint.lang-rb
    | additive = one_of_('+-')
      assert_equal '+', additive.parse('  +')
h3
  | prim
  span.params title='params'
    ' (type, options={})
  span.constraints title='should include Rsec::Helper' helper
pre.desc
  | Primitive parser, returns nil if overflow or underflow.
    There can be an optional '+' or '-' at the beginning of string except unsinged_int32 | unsinged_int64.
    type =
      :double |
      :hex_double |
      :int32 |
      :int64 |
      :unsigned_int32 |
      :unsigned_int64
    options:
      :allowed_sign => '+' | '-' | '' | '+-' (default '+-')
      :allowed_signs => (same as :allowed_sign)
      :base => integer only (default 10)
i.example example:
pre.code
  code.prettyprint.lang-rb
    | p = prim :double
      assert_equal 1.23, p.parse('1.23')
      p = prim :double, allowed_sign: '-'
      assert_equal 1.23, p.parse('1.23')
      assert_equal -1.23, p.parse('-1.23')
      assert_equal Rsec::INVALID, p.parse('+1.23')
      p = prim :int32, base: 36
      assert_equal 49713, p.parse('12cx')
h3
  | seq
  span.params title='params'
    ' (*xs)
  span.constraints title='should include Rsec::Helper' helper
pre.desc
  | Sequence parser
i.example example:
pre.code
  code.prettyprint.lang-rb
    | assert_equal ['a', 'b', 'c'], actualseq('a', 'b', 'c').parse('abc')
h3
  | seq_
  span.params title='params'
    ' (*xs)
  span.constraints title='should include Rsec::Helper' helper
pre.desc
  | Sequence parser with skippable pattern(or parser)
    option
      :skip default= /\s*/
i.example example:
pre.code
  code.prettyprint.lang-rb
    | assert_equal ['a', 'b', 'c'], actualseq_('a', 'b', 'c', skip: ',').parse('a,b,c')
h3
  | symbol
  span.params title='params'
    ' (pattern, skip=/\s*/)
  span.constraints title='should include Rsec::Helper' helper
pre.desc
  | A symbol is something wrapped with optional space
h3
  | word
  span.params title='params'
    ' (pattern)
  span.constraints title='should include Rsec::Helper' helper
pre.desc
  | A word is wrapped with word boundaries
i.example example:
pre.code
  code.prettyprint.lang-rb
    | assert_equal ['yes', '3'], seq('yes', '3').parse('yes3')
      assert_equal INVALID, seq(word('yes'), '3').parse('yes3')
h3
  | map
  span.params title='params'
    ' (lambda_p=nil)
pre.desc
  | Transform result
i.example example:
pre.code
  code.prettyprint.lang-rb
    | parser = /\w+/.r.map{|word| word * 2}
      assert_equal 'hellohello', parser.parse!('hello')
h3
  | join
  span.params title='params'
    ' (inter)
pre.desc
  | "p.join('+')" parses strings like "p+p+p+p+p".
    Note that at least 1 of p appears in the string.
    Sometimes it is useful to reverse the joining:
    /\s*/.r.join('p').odd parses string like " p p  p "
h3
  | |
  span.params title='params'
    ' (y)
pre.desc
  | Branch parser, note that rsec is a PEG parser generator,
    beware of the difference between PEG and CFG.
h3
  | *
  span.params title='params'
    ' (n)
pre.desc
  | Repeat n or in a range.
    If range.end &lt; 0, repeat at least range.begin
    (Infinity and -Infinity are considered)
h3
  | maybe
pre.desc
  | Appears 0 or 1 times, result is wrapped in an array
i.example example:
pre.code
  code.prettyprint.lang-rb
    | parser = 'a'.r.maybe
      assert_equal ['a'], parser.parse('a')
      assert_equal [], parser.parse('')
h3
  | star
pre.desc
  | Kleen star, 0 or more any times
h3
  | &
  span.params title='params'
    ' (other)
pre.desc
  | Lookahead predicate, note that other can be a very complex parser
h3
  | ^
  span.params title='params'
    ' (other)
pre.desc
  | Negative lookahead predicate
h3
  | fail
  span.params title='params'
    ' (*tokens)
pre.desc
  | When parsing failed, show "expect tokens" error
h3
  | >>
  span.params title='params'
    ' (other)
pre.desc
  | Short for seq_(parser, other)[1]
h3
  | <<
  span.params title='params'
    ' (other)
pre.desc
  | Short for seq_(parser, other)[0]
h3
  | eof
pre.desc
  | Should be end of input after parse
h3
  | cached
pre.desc
  | Packrat parser combinator, returns a parser that caches parse result, may optimize performance
h3
  | []
  span.params title='params'
    ' (idx)
  span.constraints title='constraints' seq, seq_
pre.desc
  | Returns the parse result at idx, shorter and faster than map{|array| array[idx]}
i.example example:
pre.code
  code.prettyprint.lang-rb
    | assert_equal 'b', seq('a', 'b', 'c')[1].parse('abc')
h3
  | unbox
  span.constraints title='constraints' seq, seq_, join, join.even, join.odd
pre.desc
  | If parse result contains only 1 element, return the element instead of the array
h3
  | inner
pre.desc
  | Think about "innerHTML"!
i.example example:
pre.code
  code.prettyprint.lang-rb
    | parser = seq('&lt;b&gt;', /[\w\s]+/, '&lt;/b&gt;').inner
      parser.parse('&lt;b&gt;the inside&lt;/b&gt;')
h3
  | even
  span.constraints title='constraints' join
pre.desc
  | Only keep the even(left, token) parts
h3
  | odd
  span.constraints title='constraints' join
pre.desc
  | Only keep the odd(right, inter) parts
h3
  | until
  span.constraints title='constraints' r
pre.desc
  | Scan until the pattern happens
h3
  | _?
pre.desc
  | alias for maybe
h3
  | expect
pre.desc
  | alias for fail
